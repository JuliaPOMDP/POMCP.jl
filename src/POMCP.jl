module POMCP

import POMDPs

import POMDPs: action, solve, create_policy
import Base.rand
import POMDPs: update, updater, create_belief, initialize_belief
import POMDPToolbox
import GenerativeModels


export
    POMCPSolver,
    POMCPUpdater,
    POMCPPolicy,
    BeliefNode,
    RootNode,
    ObservationNode,
    solver,
    action,
    create_policy,
    update,
    updater,
    create_belief,
    init_V,
    init_N,
    sparse_actions,
    estimate_value,
    extract_belief,
    POMCPTreeVisualizer

"""
The POMCP Solver type
"""
type POMCPSolver <: POMDPs.Solver
    eps::Float64 # will stop simulations when discount^depth is less than this
    c::Float64
    tree_queries::Int
    rng::AbstractRNG
    node_belief_updater::POMDPs.Updater

    value_estimate_method::Symbol # :rollout or :value
    rollout_solver::Union{POMDPs.Solver, POMDPs.Policy}

    num_sparse_actions::Int # = 0 or less if not used
end

include("types.jl")
include("constructor.jl")
include("particle_filter.jl")

"""
Chooses a child node based on the observation.
"""
type POMCPUpdater <: POMDPs.Updater{BeliefNode}
    node_belief_updater::POMDPs.Updater # updates the belief between nodes if necessary
end

updater(policy::POMCPPolicy) = POMCPUpdater(policy.solver.node_belief_updater)
create_belief(updater::POMCPUpdater) = ObsNode()
initialize_belief(up::POMCPUpdater, b::POMDPs.AbstractDistribution, new_belief::BeliefNode) = RootNode(0, b, Dict{Any,ActNode}())
initialize_belief(up::POMCPUpdater, b::POMDPs.AbstractDistribution) = RootNode(0, b, Dict{Any,ActNode}())
initialize_belief(::POMCPUpdater, n::RootNode, ::ObsNode) = n

function update(updater::POMCPUpdater, b_old::BeliefNode, a, o, b=nothing)
    if !haskey(b_old.children[a].children, o)
        # if there is no node for the observation, attempt to create one
        # TODO this will fail for the particle filter... then what?
        new_belief = update(updater.node_belief_updater, b_old.B, a, o)
        new_node = ObsNode(o, 0, new_belief, b_old.children[a], Dict{Any,ActNode}())
        b_old.children[a].children[o] = new_node
    end
    return b_old.children[a].children[o]
end
function rand(rng::AbstractRNG, d::BeliefNode, s)
    rand(rng, d.B, s)
end
function rand(rng::AbstractRNG, d::BeliefNode)
    rand(rng, d.B)
end


## Methods for specialization

"""
    extract_belief(rollout_updater::POMDPs.Updater, node::ObsNode) = initialize_belief(rollout_updater, node.B)

Return a belief compatible with the `rollout_updater` from the belief in `node`.

When a rollout simulation is started, this method is used to create the initial belief (compatible with `rollout_updater`) based on the appropriate `BeliefNode` at the edge of the tree. By overriding this, a belief can be constructed based on the entire tree or entire observation-action history. If this is not overriden, by default it will use initialize_belief on the belief associated with the node directly, i.e. `POMDPs.initialize_belief(rollout_updater, node.B)`.
"""
extract_belief(rollout_updater::POMDPs.Updater, node::BeliefNode) = initialize_belief(rollout_updater, node.B)
# some defaults are provided
extract_belief(::POMDPToolbox.VoidUpdater, node::BeliefNode) = nothing
extract_belief{O}(::POMDPToolbox.PreviousObservationUpdater{O}, node::BeliefNode) = Nullable{O}(node.label)
extract_belief{O}(::POMDPToolbox.PreviousObservationUpdater{O}, node::RootNode) = Nullable{O}()
extract_belief{O}(::POMDPToolbox.FastPreviousObservationUpdater{O}, node::BeliefNode) = node.label
extract_belief{O}(::POMDPToolbox.FastPreviousObservationUpdater{O}, node::RootNode) = error("Observation not available from a root node.")

"""
    sparse_actions(pomcp::POMCPPolicy, pomdp::POMDPs.POMDP, h::BeliefNode, num_actions::Int)

Return an iterable object containing no more than `num_actions` actions to be considered at the current node.

Override this if you want to choose specific actions (you can override based on the POMDP type at the node level, or the belief type). If only a limited number of actions are to be considered, this function will be used to generate that set of actions. By default, it simply returns a random sampling of actions from the action space generated by `POMDPs.actions`.

If your problem has a continuous action space, you will want to override this to try a sensible set of action samples.
"""
function sparse_actions(pomcp::POMCPPolicy, pomdp::POMDPs.POMDP, h::BeliefNode, num_actions::Int)
    return sparse_actions(pomcp, pomdp, h.B, num_actions)
end
function sparse_actions(pomcp::POMCPPolicy, pomdp::POMDPs.POMDP, b::Any, num_actions::Int)
    if num_actions > 0
        all_act = collect(POMDPs.iterator(POMDPs.actions(pomdp, b)))
        selected_act = Array(Any, min(num_actions, length(all_act)))
        len = length(selected_act)
        for i in 1:len
            j = rand(pomcp.solver.rng, 1:length(all_act))
            selected_act[i] = all_act[j]
            deleteat!(all_act, j)
        end
        return selected_act
    else
        return POMDPs.iterator(POMDPs.actions(pomdp, b))
    end
end

# TODO: Not sure if the arguments for this are right
"""
    init_V(problem::POMDPs.POMDP, h::BeliefNode, action)

Return the initial value (V) associated with a new action node when it is created. This can be used in concert with `init_N` to incorporate prior experience into the solver.
"""
function init_V(problem::POMDPs.POMDP, h::BeliefNode, action)
    return 0.0
end

# TODO: Not sure if the arguments for this are exactly what's needed
"""
    init_N(problem::POMDPs.POMDP, h::BeliefNode, action)

Return the initial number of queries (N) associated with a new action node when it is created.
"""
function init_N(problem::POMDPs.POMDP, h::BeliefNode, action)
    return 0
end

"""
    estimate_value(pomcp::POMCPPolicy, problem::POMDPs.POMDP, start_state, h::BeliefNode)

Return an initial unbiased estimate of the value at belief node h.

By default this runs a rollout simulation
"""
function estimate_value(pomcp::POMCPPolicy, problem::POMDPs.POMDP, start_state, h::BeliefNode)
    if pomcp.solver.value_estimate_method == :value
        return POMDPs.value(pomcp.solver.rollout_policy, h.B) # this does not seem right because it needs to be given the start state
    elseif pomcp.solver.value_estimate_method == :rollout
        return rollout(pomcp, start_state, h)
    else
        error("POMCPSolver.value_estimate_method should be :value or :rollout (it was $(pomcp.solver.value_estimate_method)).")
    end
end

include("solver.jl")
include("visualization.jl")

end # module
